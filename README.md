# Pray on Monday

## 웹

1. 브라우저에서 www.daum.net을 입력하면 어떤 일이 일어나나요.

- 브라우저는 URL을 파싱하여, 프로토콜과 URL, 포트를 분석합니다. 
- URL에 해당하는 IP주소를 찾기위해 DNS캐시,HOST파일,DNS서버 순으로 검색을 하며, IP주소를 알아내면 해당 IP주소에 해당하는 서버와 3WAY HAND SHAKE 과정을 통해 TCP 소켓 연결을 진행합니다.
- 소켓 연결이 되면, HTTP 요청을 보내고, 응답을 받습니다. 
- 응답을 통해 HTML문서를 받은 브라우저는 HTML,CSS 파싱과정을 거쳐 DOM TREE와 CSSOM 트리를 완성합니다.
- 두 트리를 기반으로 RENDER TREE를 만들며, RENDER TREE를 기반으로 리플로우라고도 불리는 레이아웃 연산과정(각요소들이 실제 브라우저 화면에 보여질 크기, 위치와 같은 값을 계산하는 과정)을 거칩니다.
- 레이아웃 연산과정이 완료되면, 페인트 과정을 거쳐 화면에 보이게 됩니다.

2. **DOM이란 ? (실제 면접에서 물어본 질문)**

- DOM이란 웹페이지에 대한 프로그래밍 인터페이스입니다. 
- 웹문서를 구조화된 노드를 통해 객체형태로 표현하며, 이러한 요소들을 자바스크립트에서 접근할 수 있도록 API를 제공합니다.

3. **CORS란 ? (실제 면접에서 물어본 질문)**

- CORS란 서버에서 허용하는 경우 다른 출처의 서버로 요청과 응답이 가능한 브라우저 상의 정책입니다.
- Preflight request라고 하는 사전 요청을 통해 허용 출처들을 질의하고, Access-Control-Allow-Origin이라는 헤더를 통해 허용하는 출처들을 리턴받습니다.
- 브라우저는 요청한 출처가 허용 출처에 포함된다면 실제 요청과 응답을 진행합니다.

4. 크로스브라우징이란 무엇이고 전략에 대해 말해보세요.

- 크로스 브라우징이란 어떠한 환경에서도 이상없이 동작시키도록 하는 방법이다. 
- 웹페이지 제작시 사용자가 사용하는 다양한 브라우저 환경에서 정상동작하도록 개발해야한다.
- 자바스크립트의 경우 라이브러리를 사용하거나, 직접 폴리필(해당 환경에서 메서드 또는 함수가 존재하지 않는 경우 런타임에 환경에 맞게 주입하는 기술)을 구현한다.
- css의 경우 브라우저마다 기본 스타일이 다르기때문에 아얘 초기화하는 reset.css나 기본스타일을 통일하는 nomalize.css를 사용하면 된다.

5. SSR과 CSR에 대해 말해보세요.

- SSR은 서버측에서 DATA가 결합된 HTML을 만들어서 클라이언트로 전달하는 방식이고, CSR은 DATA가 결합되지 않은 HTML파일을 받은 후 클라이언트에서 비동기적으로 DATA를 받아와 렌더링하는 방식이다.
- SPA는 최초에 한번 페이지를 로딩한후 즉, HTML 파일을 한번만 받은 뒤 클라이언트단에서 데이터만 변경해 사용하는 어플리케이션이다.

6. GET과 POST의 차이점에 대해 말해보세요.

- GET 방식은 보통 서버에 데이터 요청시 사용하는 HTTP METHOD 중 하나입니다.
- GET 방식은 브라우저에 캐싱되며, URL을 통해 쿼리문자열이 전달되므로 쿼리문자열 길이의 제한이 있습니다.
- POST 방식은 보통 서버에 데이터 입력시 사용하는 HTTP METHOD 중 하나입니다.
- POST 방식은 브라우저에 캐싱되지 않으며, HTTP 본문을 통해 데이터가 전달되므로, 데이터 길이의 제한이 없습니다.

7. 브라우저 저장소에 대해 설명해보세요.

- 브라우저 저장소에는 쿠키와 웹스토리지 라는 것이 있습니다.
- 쿠키는 보통 서버에서 클라이언트를 식별하기위해 전달하는 값으로 사용됩니다.
- 쿠키는 길이의 제한이 있으며, SetCookie라는 서버의 응답헤더를 통해 설정될수도 있습니다.
- 쿠키는 유효기간이 존재하며, 도메인별로 저장됩니다. 그리고 http 요청시마다 첨부되어 전송됩니다.
- 웹스토리지는 key/value 기반의 세션스토리지와 로컬스토리지 두가지가 있습니다.
- 로컬 스토리지는 영구적으로 저장할수 있으며, 도메인별로 생성됩니다. 그리고 브라우저를 종료해도 데이터가 남아있습니다.
- 세션 스토리지는 브라우저 탭마다 존재하며, 탭을 종료하면 소멸됩니다.

8. **HTML 렌더링 중 자바스크립트 코드가 실행되면 멈추는 이유가 뭔가요 ?? (실제 면접에서 물어본 질문)**

- HTML 파싱과정에서 CSS파일 또는 자바스크립트 코드는 블로킹 요소입니다.
- 즉, 파싱과정중 자바스크립트 코드를 만나게되면, 파싱과정을 중지하고 자바스크립트 코드를 수행합니다.
- 실행이 완료되면, HTML 파싱과정을 다시 진행하기때문에 렌더링이 잠시 멈추게 됩니다.

9. HTTP 버전별 특징에 대해 말해보세요.

- 0.9버전은 가장 초기버전으로 GET통신만 가능하며, HTTP헤더가 존재하지않아, 오류발생시 HTML문서안에 포함되었습니다.
- 1.0에서 HTTP 헤더가 등장했고, POST방식이 추가되었습니다.
- 1.1은 현재 가장 표준적인 버전이며, 지금 일반적으로 사용하는 HTTP METHOD가 모두 등장했습니다.
- 또한 Keep alive라는 기능이 추가되어 소켓 커넥션을 맺은뒤 일정 시간동안은 유지되도록 성능이 개선되었습니다. 
- 2.0은 가장 최신 버전이며, 이진 프로토콜이라고만 알고있습니다. 또한 하나의 http 요청을 통해 여러개 자원을가져올 수 있는것으로 알고있습니다.
 
10. HTML5에 대해 말해보세요.

- 과거에는 동영상 음악감상,은행업무등과 같은 인터넷 서비스를 플러그인 설치를 통해 제공하였는데, 이러한 기능들이 브라우저 자체에서 제공할 수 있도록 고안하여 등장한것이 HTML5입니다.
- 지금 많이 사용하는 웹소켓 , 웹스토리지, 카메라,마이크 액세스,CSS3같은 기술들이 HTML5 스펙에 포함되어있습니다.

11. REST API란 ? 

- HTTP 프로토콜 본연의 특징을 최대한 활용하여 API를 설계하는 방법론입니다.
- HTTP METHOD로 CRUD를 표현하고 URL을 통해 자원을 명시함으로써 자원에 대한 CRUD 오퍼레이션을 정의할 수 있습니다.
- API가 이해하기 쉽고, 설계하기 단순하여 많이 사용됩니다.

12. 시멘틱 태그란 ?

- SEO 최적화를 위해 봇에서 크롤링시 HTML의 각 태그들이 어떠한 역할을 하는지 의미적으로 부여한 태그들입니다.
- header,section,aside,footer와 같은 태그들이 시멘틱 태그들입니다.

## 자바스크립트

1. **호이스팅에 대해 설명해보세요. (실제 면접에서 물어본 질문)**

- 호이스팅이란 변수,함수의 선언부가 최상위로 끌어올려지는 것을 말합니다. 
- 자바스크립트 엔진은 선언문을 구문분석과정에서 해석하고, 할당문은 런타임과정에서 실행되기에 선언부가 최상위로 끌어올려집니다. 
- var 변수와 함수 선언문의 경우 선언부가 함수 스코프의 최상위로 끌어올려지며, 함수선언문은 구현부까지 같이 끌어 올려집니다. 
- let const는 보통 호이스팅되지 않는다고 알고있으나 실제로는 블록 스코프의 최상위로 끌어올려집니다. 
- 스코프 시작지점과 초기화지점 사이를 temparal dead zone이라고 하는 데, 이 영역에서 let const를 참조하면 아직 초기화되지 않았다는 에러가 뜹니다.

2. **클로저에 대해 설명해보세요. 클로저를 언제 사용하나요. (실제 면접에서 물어본 질문)**

- 클로저는 고차함수 안에서 리턴되는 함수안에서 외부함수의 변수를 참조하는 경우 고차 함수의 호출이 종료되어도, 리턴된 함수에서 상위 스코프의 변수를 지속적으로 참조가능한 메커니즘을 말합니다.
- 클로저는 보통 고차함수에서 동적인 함수를 리턴할때 많이 사용이됩니다. 예를 들어 고차함수 매개변수로 3을 입력받고 리턴되는 함수에서 3을 참조하여 3의 배수를 리턴하는 함수를 생성할 수 있습니다.

3. **스코프체인에 대해 설명해보세요. (실제 면접에서 물어본 질문)**

- 스코프체인은 자바스크립트에서 변수를 찾는 메커니즘입니다. 실행중인 렉시컬 환경에 변수정보가 없다면 상위스코프를 따라 올라가며 찾는 방식이며, window 객체까지 도달하여 변수 정보가 없다면, undefined라는 에러를 출력합니다.

4. **this란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- this는 window객체로 초기화가 됩니다. 하지만 함수 호출패턴에 따라 그 의미와 값을 달리할 수 있습니다. 

5. **함수 호출 패턴에서 따른 this 값에 대해 설명해보세요. (실제 면접에서 물어본 질문)**

- 일반적인 함수호출의 경우 window 객체이며, 메서드 호출의 경우 메서드를 호출한 객체가 this가 됩니다.
- 생성자함수의 경우 생성되는 객체가 this가 됩니다.
- 또한 this는 call,apply,bind와 같은 this 바인딩 메서드을 통해서도 값을 달리할 수 있습니다.
- call의 경우 함수 호출시 사용하며, 인자전달시 쉼표로 구분하여 전달합니다. 또한 apply경우도 함수호출시 사용하며, 인자 전달시 배열의 형태로 전달합니다.
- bind는 함수 선언시 사용하며 선언문 뒤에 붙입니다.

6. 자바스크립트 언어의 특징에 대해 말해보세요.

- 자바스크립트는 싱글스레드 언어이며, 한줄씩 분석해가며 실행하는 인터프리터 언어입니다.
- 또한 함수를 일급객체(변수에 할당,인자전달,함수에서 리턴이 가능) 취급하기 떄문에 함수형 프로그래밍이 가능합니다.
- 그리고 최근 자바스크립트 엔진은 JIT 컴파일러가 내장되어 있어 자주 반복되는 바이트 코드를 기계어로 컴파일하여 실행속도를 최적화합니다.

7. 자바스크립트는 싱글스레드인데 어떻게 비동기를 지원하나요 ?

- 자바스크립트는 싱글스레드로 동작하지만, 자바스크립트 일부 기능들은 Web api를 사용합니다. 
- Web api는 자바스크립트 엔진이 아닌 독립적인 영역에서 실행되며, 전달된 콜백함수는 web api가 종료되면 이벤트큐로 전달되고 자바스크립트 코드가 모두 실행되면 이벤트 루프에 의해 큐에 꺼내지어 호출스택에 올라갑니다.
- 이러한 흐름이 비동기적 실행을 가능하게 만듭니다.

9. **이벤트 루프란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 이벤트 루프는 호출스택이 비게 되면 이벤트 큐에 저장된 함수들을 호출스택에 올려 실행하는 스케쥴러입니다. 

10. **setTimeout 을 0초로 설정한 콜백함수와 Promise resolve의 콜백함수중 뭐가 먼저 실행되나요 ? (실제 면접에서 물어본 질문)**

- setTimeout의 경우 콜백함수가 테스크 큐에 저장되고, Promise resolve 콜백함수의 경우, 마이크로 테스크 큐에 저장됩니다.
- 브라우저마다 각 큐의 우선순위는 다를수 있으나, 크롬의 경우 마이크로 테스크 큐가 우선순위가 높기때문에 Promise resolve의 콜백함수가 먼저실행됩니다.

11. 자바스크립트를 멀티쓰레드로 실행하는 방법에 대해 말해보세요. 

- 자바스크립트는 싱글스레드로 동작하기떄문에 연산량이 많은 작업을 할 경우, 웹워커를 생성하여, 멀티쓰레드로 실행 시킬 수 있습니다.
- 워커는 dom에 접근할수 없으므로, 메인쓰레드와의 통신을 통해 연산의 결과를 전달 받을 수 있습니다.

12. **렉시컬 스코프란 무엇이고, 이와 반대되는 개념은 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 프로그래밍 언어에서 함수의 선언 위치에 따라 상위스코프가 결정되는 것을 렉시컬 스코프라고합니다.
- 렉시컬 스코프는 렉싱타임에 즉, 구문분석 과정에서 상위스코프가 결정되므로 렉시컬 스코프라 부릅니다.
- 반대되는 개념은 동적 스코프이며, 동적스코프는 함수 호출 위치에 따라 상위스코프가 결정됩니다.
- 동적스코프는 런타임에 상위스코프가 결정됩니다.

13. 비동기적으로 실행되는 것을 동기적으로 코딩하는 방법에 대해 말해보세요.

- 우선 비동기 함수들은 콜백 중첩을 통해 동기적으로 실행시킬수 있습니다.
- 콜백 중첩은 가독성을 떨어뜨리기 때문에 Promise객체를 사용하여 가독성을 올릴수 있습니다.
- Promise 객체생성 즉시 Promise 객체는 pending(약속을 수행중인) 상태가 되며, resolve 호출시 fulfilled,reject호출시 rejected 상태가 되어, 해당 상태에 따른 콜백함수가 호출되도록 설계되어 있습니다.
- then 체이닝과 Promise 객체생성을 통해 콜백 중첩보다는 가독성 좋은 코드 작성이 가능합니다.
- async await은 비동기 함수를 처리하는 가장 최신 문법입니다.
- await은 어짜피 Promise 객체를 대상으로 블록하기때문에 Promise가 같이 사용된다고 할 수 있습니다.
- async키워드로 선언된 함수에서만 await 문법 사용이 가능합니다.

14. **DOM 이벤트란 무엇이고, 이벤트의 흐름은 어떻게 되는지 말씀해보세요. (실제 면접에서 물어본 질문)**

- DOM 이벤트는 브라우저 이벤트 인터페이스에 맞춰 구현된 객체입니다.
- 해당 객체는 사용자 인터렉션 또는 DOM 변화,브라우저로 부터 생성 및 전파됩니다.
- 이벤트의 흐름은 부모 엘리먼트에 의존합니다. window 객체부터 이벤트가 발생한 엘리먼트까지 이벤트가 전파되며, 이과정을 캡처링 이라고 합니다. 캡처링 단계이후, 다시 부모엘리먼트를 따라 window 객체까지 타고 올라가는 버블링 단계가 있습니다.
- 이벤트 흐름을 중단하기 위한 메서드로는 stopPropagation(다음 엘리먼트로의 전파 중단),stopImmediatePropagation(이벤트가 발생한 엘리먼트 내에서 전파 중단)이 있습니다.

15. **실행컨텍스트란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 실행컨텍스트는 자바스크립트 실행시 함수가 호출될때마다 호출스택에 생성되는 물리적 객체입니다.
- 코드가 실행되면 최초로 전역 실행 컨텍스트가 생성되며, 함수 호출마다 함수 실행 컨텍스트가 생성됩니다.
- 실행컨텍스트는 ES6가 나온 뒤로 렉시컬 환경과 변수 환경이라는 두개의 컴포넌트를 갖고 있는데, 렉시컬 환경은 let,const,함수에 대한 정보와 상위 스코프에 대한 참조, 함수 환경은 var에 대한 정보를 갖고 있습니다.

16. require와 import의 차이점에 대해 말씀해보세요.

- require는 Commonjs 모듈화 방식이며, import는 ES6에서 등장한 ESM 방식입니다.
- 과거 브라우저는 ESM방식을 지원하지 않았기떄문에 ESM은 바벨과 함께 사용하는 경우가 보통입니다.
- require와 달리 import는 필요한 객체 또는 함수만 로드하여 메모리 절약이 가능합니다.

17. **ES6의 화살표 함수는 언제 사용하고, 왜쓰나요 ? (실제 면접에서 물어본 질문)**

- 화살표 함수는 함수 표현식을 간결하게 할 수 있고, this값을 가지고 있지 않습니다.
- 즉, this를 참조하는 경우 상위스코프의 this를 참조하게 됩니다.
- this는 메서드가 아닌 일반함수에서 상위스코프의 this를 참조해야할 떄 사용됩니다. 
- 예를들면 메서드 내부에 setTimeout이 사용되는 경우 콜백함수를 arrow function으로 선언하면 this가 메서드 객체를 가르키게 할 수 있습니다.

18. **var let const 의 차이점에 대해 말씀해보세요 ! (실제 면접에서 물어본 질문)**

- var는 함수 스코프를 따르며, let const는 블록 스코프를 따릅니다.
- 함수 스코프란 함수단위로 스코프가 정해지는 것을 말합니다.
- 블록 스코프란 블록단위로 스코프가 정해지는 것을 말합니다.

19. 이터러블 객체란 무엇이며, 이터레이터객체란 무엇인가요 ?

- 이터러블 객체란, for of와 같은 문법을 통해 반복 가능한 객체로 이터레이터 객체를 반환하는 Symbol.iterator(심볼이란 es6에서 등장한 타입으로 충돌이 없는 키로써 활용됩니다)라고 하는 특수 내장 심볼 프로퍼티를 가진 객체입니다.
- 이터레이터 객체란, next메서드를 통해 반복에 사용될 값을 만들어내는 객체입니다.
- next 메서드는 반복의 상태를 객체형태로 반환하는데 done 프로퍼티가 true일 경우 반복이 끝나고, done 프로퍼티가 false일 경우 반복이 가능한 상태로 값을 리턴합니다.

20. **제너레이터란 무엇이며, 제너레이터 함수란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 제너레이터 객체는 여러개의 값을 필요에 따라 하나씩 반환하는 객체입니다. 이터러블 객체라고 보면되는데, 제너레이터 함수를 이용해 쉽게 생성할 수 있습니다.
- 제너레이터 함수는 제너레이터 객체를 생성하는 함수입니다. 제너레이터가 반환할 로직을 함수에서 yield 키워드를 통해 정의합니다.

21. **쓰로틀과 디바운스의 차이점에 대해 말해보세요. (실제 면접에서 물어본 질문)**

- 디바운스은 특정 시간간격안에 많은 이벤트가 발생할때, 마지막 이벤트에 대해서만 함수호출이 되게하는 기술입니다. 
- 즉, 디바운스는 이벤트가 발생하고 특정 시간간격안에 이벤트가 연속적으로 발생하면 함수호출을 계속 지연시키는 기술입니다.
- 쓰로틀은 특정 시간간격마다 함수호출을 보장하지만(특정 시간간격마다 함수호출이 보장된다.), 디바운스는 이벤트가 계속 연속적으로 발생한다면 무한정 지연될수 있습니다.

22. **프로토타입이란 뭔가요 ? 구조에 대해 설명해보세요. (실제 면접에서 물어본 질문)**

- 생성자 함수 또는 class를 기반으로 생성된 객체의 원형이 되는 객체가 프로토타입 객체입니다. 함수 및 class 선언시 생성됩니다.
- 함수의 prototype프로퍼티를 통해 프로토타입객체에 대한 참조가 가능하며, 생성된 객체는 `__proto__`라는 키워드를 통해 프로토타입 객체에 대한 참조가 가능합니다.
- 또한 프로토타입객체의 생성자는 자신을 생성한 객체를 가르킵니다.
- 프로토타입 객체에 변수 또는 메서드를 할당하면 생성된 객체에서 마치 자신의 메서드인 것처럼 사용이 가능합니다.

23. **프로토타입 체인이란 뭔가요 ? (실제 면접에서 물어본 질문)**

- 프로토타입 체인이란 프로퍼티를 검색하는 메커니즘입니다.
- 객체에 프로퍼티가 존재하지 않으면 proto 프로퍼티를 통해 프로토타입 객체에 해당 프로퍼티가 존재하는지 확인하고 있다면 마치 자신의 것처럼 사용가능합니다.
- 또 프로토타입 객체에도 없다면 해당 프로토타입 객체의 `__proto__` 프로퍼티가 가르키는 객체에서 찾습니다. 이런식으로 계속 따라 올라가는데 Object 프로토타입 객체를 거쳐 null 나올때까지 찾아들어갑니다.
- 프로토타입 메커니즘을 활용해 상속이라고 하는 개념을 사용할 수 있습니다.

24. **이벤트 위임기법이란 뭔가요 ? 장점은 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 이벤트 위임기법이란 버블링이라고하는 이벤트 흐름을 이용하여 상위엘리멘트 이벤트 리스너를 통해 하위 엘리먼트에서 발생한 이벤트를 다루는 기술입니다.
- 리스너를 하나만 만들기때문에 메모리 효율성 측면에서 좋습니다.
- 여러 엘리먼트에서 발생하는 이벤트를 하나의 리스너에서 관리하기 때문에 이벤트 관리에 좋습니다.

25. 무한스크롤 구현방법에 대해 말씀해보세요.

- 무한 스크롤의 경우 저는 IntersectionObserver라는 객체를 사용하여 구현합니다.
- 옵저버 객체를 생성후 옵저버객체가 관찰할 대상 엘리먼트를 등록할 수 있습니다.
- 관찰 대상 엘리먼트가 교차영역에 들어오면 콜백함수가 호출되며, 교차영역에 들어온 엘리먼트의 목록을 콜백함수의 인자로 전달받습니다.
- 무한 스크롤 구현시 가장 밑바닥에 엘리먼트를 하나두고 해당 엘리먼트가 교차영역에 들어오면 추가적인 데이터를 요청하는 방식으로 구현합니다.

26. 이미지 레이지 로딩이란 무엇이며, 구현하는 방법을 말씀해보세요.

- 이미지 레이지 로딩도 IntersectionObserver라는 객체를 사용하여 구현합니다.
- 모든 이미지 태그는 src 속성을 비워두고 dataset 속성에 이미지 url을 설정해놓습니다.
- 그리고 교차영역에 들어오는 순간 dataset 속성의 이미지 url을 src 속성에 설정합니다.

27. defer과 async의 차이점에 대해 말해보세요.

- 브라우저는 defer속성이 박힌 스크립트를 백그라운드에서 다운로드합니다. 즉, html 파싱과정과 독립적으로 로드합니다.
- 하지만 defer는 dom이 준비된 이후 실행됩니다. 또 DOMContentLoaded가 발생하기 전에 실행됩니다.
- 그리고 defer속성이 박힌 스크립트는 태그된 순서에 따라 순차적으로 실행됩니다.
- async는 페이지와 완전히 독립적으로 동작합니다.
- 실행시 dom을 기다리지도 않으며, 태그된 순서와 관계없이 모든 async 태그는 비동기적으로 실행됩니다.

28. **디바운스를 직접 구현해보세요. (라이브코딩 - 실제 면접에서 물어본 질문)**

- setTimeout과 clearTimeout으로 구현

29. **resize할때마다 핸들러가 호출되게 구현해보세요 (라이브코딩 - 실제 면접에서 물어본 질문)**

- window.addEventListener('resize',handler);

## 프레임워크

1. **리액트에서 setState는 왜쓰나요 ? (실제 면접에서 물어본 질문)**

- 리액트에서는 상태변화에 따른 뷰의 변화를 추구합니다.
- 허나 리액트에서는 기존 state를 직접 변경한다고 리렌더링 되지 않습니다.
- 그러므로 setState를 사용해야합니다.

2. **리액트에서 state가 불변해야하는 이유는 뭔가요 ? (실제 면접에서 물어본 질문)**

- 리액트는 setState 메서드를 통해 전달된 객체와 기존 state 객체 주소비교를 통해 다름을 감지하고 다를시에 리렌더링을 수행하므로 새로운 객체를 setState의 인자로 전달해야합니다.
- 즉, 리액트가 상태변화를 감지하려면 불변성을 유지해야합니다.
- shouldComponentUpdate은 리렌더링 여부를 결정하는 메서드인데 인자로 변경될 state객체를 받습니다. 이때 불변성을 유지해야만, 이전 객체와 변경될 객체의 비교가 수월하기 때문에 불변성을 유지해야합니다.
- 리덕스에서도 reducer를 순수함수(입력데이터를 변경하지 않고 동일한 입력데이터에 대해 동일한 출력값을 일관되게 리턴하는 함수)로 사용하기 위해 인자로 전달된 state의 불변함을 유지한다. redux자체가 내부적으로 주소비교를 통해 변경을 감지하므로 state를 불변하게 유지해야한다.

3. **리액트에서 key는 왜쓰나요 ?? (실제 면접에서 물어본 질문)**

- 배열을 기반으로map함수를 사용해 엘리먼트 리스트를 생성하는 경우, 이전 엘리먼트와 생성될 엘리먼트의 key값을 기반으로 변경을 감지하여 리렌더링여부를 결정합니다. 이때, 엘리먼트 식별 및 리렌더링의 효율성을 위해 key를 사용합니다. 
- 또한 key로 인덱스를 사용하면 안됩니다. 배열의 순서가 이전과 동일하다는 것이 보장되지 않기때문에 이전에 사용되었던 배열의 요소라도 인덱스변화로 인해 다른 요소로 식별되어 리렌더링되는 이슈를 발생시킬수 있기때문입니다.

4. **useEffect란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- useEffect는 함수형 컴포넌트에서 사용하는 훅 종류중 하나입니다.
- 렌더링이 완료되어 dom이 준비되면 비동기적으로 호출되는 부수효과함수입니다.
- 의존성 배열에 상태를 추가하여 상태 변화에 따라 매번 호출되게 할 수도있으며,
- 빈배열로 선언시 컴포넌트 생성시 한번만 호출됩니다.
- 또한 함수를 리턴할수도 있는데 리턴하는 함수는 useEffect함수가 호출되기 직전과 컴포넌트가 소멸될때 호출됩니다.

5. **함수형 컴포넌트와 클래스형 컴포넌트의 차이점에 대해 말씀해보세요. (실제 면접에서 물어본 질문)**

- 함수형 컴포넌트는 함수로 작성 컴포넌트이고, 클래스형 컴포넌트는 클래스로 작성된 컴포넌트입니다.
- 과거 함수형 컴포넌트는 상태가 존재하지 않는 정적 컴포넌트였으나, 훅의 등장으로 state를 사용할수 있게되었습니다.
- 또한 함수형 컴포넌트에서는 생명주기를 훅을 통해 관리하지만 클래스형 컴포넌트에서는 생명주기 메서드들을 활용해 관리합니다.

6. **함수형 컴포넌트에서 상태관리 방법이 뭔가요 ? (실제 면접에서 물어본 질문)**

- 함수형 컴포넌트에서는 useState를 사용해 상태값과 상태값을 갱신하는 함수를 생성하여 관리할 수 있습니다.

7. **useEffect는 클래스형 컴포넌트의 어떤 생명주기 함수를 대체할 수 있나요 ? (실제 면접에서 물어본 질문)**

- 클래스형 컴포넌트 생명주기 메서드들 중 componentDidUpdate와 componentDidMount, componentWillUnmount를 대체할 수 있습니다. componentWillUnmount의 경우 리턴되는 함수를 통해 대체가능합니다.

8. **HOC란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- 고차 컴포넌트함수로써 컴포넌트를 인자로 받아 인자로 받은 컴포넌트를 렌더링하는 새로운 컴포넌트를 리턴합니다.
- 인자로 받은 컴포넌트를 새로운 컴포넌트로 감싸 컴포넌트를 데코레이팅 하는데 사용할 수 있습니다. 
- 예를들어 여러 컴포넌트가 공통적으로 수행해야하는 로직 수행후 props로 전달되야 할때, HOC로 해당 기능들을 데코레이팅 할 수있습니다. 로직 재사용성 측면에서 매우 유용합니다.

9. **Redux-saga란 무엇이며, saga의 동작원리를 제네레이터함수와 연관지어 말씀해보세요. (실제 면접에서 물어본 질문)**

- redux를 사용시 특정 action을 후킹하여 비동기 요청시 redux saga를 사용할 수 있습니다.
- 비동기요청결과는 리듀서함수의 페이로드로 전달됩니다.
- saga를 미들웨어로 등록하여 특정액션을 캐치하도록 할 수 있습니다.
- saga 작성시 제너레이터 함수를 사용하는데, yield 키워드를 사용해 액션을 기다리는 take 함수 실행을 반복시키기 위함입니다.

10. **Virtual Dom이란 무엇인가요 ? (실제 면접에서 물어본 질문)**

- Virtual dom이란 실제돔을 추상화한 객체입니다. 
- DOM API를 사용해 DOM을 수정하는 경우 리플로우가 발생하는데, API를 사용할떄마다 발생하여, 연산비용이 증가할 수 있습니다.
- 하지만 Virtual dom에 변경된 내역을 모으고 한번에 실제돔에 적용한다면 리플로우 과정을 한번만 수행하면 되기때문에 효율적입니다.

11. **shouldComponentUpdate 메서드에 대해 설명해주세요. (실제 면접에서 물어본 질문)**

- 리렌더링이 발생하기 직전 호출되는 메서드로 변경된 상태값과 Props를 전달받습니다.
- true를 리턴하면 리렌더링을 수행하고 false를 리턴하면 리렌더링을 수행하지 않습니다.
- 상태값 비교를 통해 리렌더링을 효율적으로 수행시키위해 사용합니다.

12. **shouldComponentUpdate 메서드에서 false를 리턴하면, 자식컴포넌트는 리렌더링이 될까요 ? (실제 면접에서 물어본 질문)**

- 아니요.

13. **shouldComponentUpdate 메서드에서 false를 리턴하면, 자식컴포넌트는 리렌더링이 되지 않는데, 리렌더링 시키는 방법은 뭘까요 ? (실제 면접에서 물어본 질문)**

- forceUpdate라고 하는 메서드를 사용하면 되는 것으로 알고 있습니다.
